{"Projects/Api-Gateway":{"title":"Api Gateway","links":[],"tags":[],"content":"Overview\nThis project is an API Gateway built using Starlette and HTTPX. It is currently in the MVP stage, focusing on basic routing functionalities.\nAbout API gateway\ncheck out RedHat docs to understand the usage.\n\nFeatures\n\nRouting: Directs incoming requests to the appropriate backend services.\n\nPlanned Features\n\nCI/CD: Test and build image on push or merge with main.\nDynamic Middleware: Allows for dynamic addition and removal of middleware.\nFirewall: Basic firewall functionalities to secure the gateway.\nDatabase Configuration: Configures and manages database connections.\nObservations: Tracks and logs requests for monitoring and debugging.\nAuthentication and Authorization: Implement security measures to control access to services.\nRate Limiting: Add functionality to limit the number of requests a client can make.\nLoad Balancing: Distribute incoming requests across multiple instances of a service.\nCaching: Store responses to reduce load on backend services.\n\nTechnologies Used\nStarlette: A lightweight ASGI framework/toolkit.\nHTTPX: An HTTP client for Python.\nGetting Started\nPrerequisites\n\nDocker\n\nInstallation\n\n\nClone the repository:\ngit clone github.com/aminmasoudi/api-gateway.git\ncd api-gateway\n\n\nCreate a settings file:\nCreate a file named prod.py in the settings directory with the necessary configuration settings.\n\n\nRun with Docker:\ndocker run -v $(pwd)/prod.py:/app/prod.py -p 8000:8000 aminmasoudii/api-gateway\n\n\nUsage\nOnce the application is running, you can access the API Gateway at http://localhost:8000.\nConfiguration\n\nprod.py: This file should contain all the necessary configuration settings for the application.\n\nContributing\nWe welcome contributions! Please follow these steps:\n\nFork the repository.\nCreate a new branch (git checkout -b feature-branch).\nMake your changes.\nCommit your changes (git commit -m ‚ÄòAdd new feature‚Äô).\nPush to the branch (git push origin feature-branch).\nOpen a pull request.\n\nAreas for Contribution\n\nFixing Cookies and CSRF Tokens: Secure handling of cookies and CSRF tokens.\nImplementing Planned Features: Work on any of the planned features listed above.\nReporting any Issue: Submit any issue you see.\n\nLicense\nThis project is licensed under the MIT License. See the LICENSE file for details.\nContact\nFor any questions or support, please contact the maintainer at aminmasoudi2003@gmail.com."},"Projects/SNA":{"title":"SNA","links":[],"tags":[],"content":"Graph-Based Social Network Analysis\nProject: A Graph-Based Social Network Analysis Tool\nObjective:\nThe task is to design and implement a program that analyzes a social network represented as a graph. The program should allow users to input the graph, specify query parameters, and retrieve meaningful insights about the network.\nGraph Representation:\nThe social network will be represented as an adjacency list or adjacency matrix, where each node represents a person, organization, or entity, and edges represent relationships between them (e.g., friendships, followers,\ncollaborations).\nFunctional Requirements:\n\nNode Information Retrieval: Write a function that takes a node ID as input and returns the node‚Äôs attributes (e.g., name, age, profession).\nEdge Traversal: Implement an algorithm to traverse the graph, starting from a given node, and retrieve all nodes reachable within a specified distance (e.g., 1-3 hops).\nCommunity Detection: Use a clustering algorithm (e.g., k-means, DBSCAN) to identify communities within the network based on edge connections.\nCentrality Measures: Calculate various centrality measures (e.g., degree, closeness, betweenness) for each node in the graph.\nQuerying: Develop an interface that allows users to input queries and retrieve relevant information about the social network. Examples of queries:\n\nFind all nodes connected to a given node within a specific distance.\nIdentify the most central nodes in the network.\nRetrieve the community structure of the network.\n\n\n\nNon-Functional Requirements:\n\nEfficiency: The program should be able to handle large-scale social networks efficiently, with acceptable running times and memory usage.\nUsability: The user interface should be intuitive, allowing users to easily input queries and retrieve results.\nError Handling: Implement robust error handling for invalid inputs or unexpected graph structures.\n\nDeliverables:\n\nA written report (5-7 pages) that:\n\nDescribes the graph representation and algorithms used.\nDiscusses the functional and non-functional requirements.\nPresents any challenges encountered during implementation and how they were addressed.\n\n\nA working program (Python, Java, or C++) with a user-friendly interface that demonstrates the above features.\n\nEvaluation Criteria:\n\nCorrectness of implemented algorithms and data structures.\nEfficiency and scalability of the program.\nUsability and intuitiveness of the user interface.\nClarity and organization of the written report.\nCreativity and originality in approach to problem-solving.\n"},"Projects/msd":{"title":"mp4 to mp3 Converter - A Micro-Services Example","links":[],"tags":[],"content":"github: micro-serv-des\nWelcome to the mp4 to mp3 converter, an example project showcasing micro-service system design concepts.\nWhat is Micro-Service Design?\nMicro-service design is an architectural style that structures an application as a collection of small, independent services. Each service runs in its own process and communicates with lightweight protocols typically over HTTP.\n\nIn a micro-service architecture, each service is designed to be:\n\nIndependent: Each service can be developed, tested, and deployed independently of other services.\nDecentralized: Services are not tightly coupled, allowing for greater flexibility and scalability.\nResilient: If one service fails or becomes unavailable, others can continue to function normally.\n\nOverview\nThis project demonstrates how to design and implement a scalable, distributed system using multiple micro-services. The app converts MP4 files to MP3 audio files, utilizing various technologies such as Docker, Kubernetes, MySQL, MongoDB, RabbitMQ, and Flask.\nFeatures\n\nConvert MP4 videos to MP3 audio files\nAuthenticates users with JWT tokens\nSaves video metadata in a MongoDB database\nSends email notifications upon conversion completion\nUtilizes RabbitMQ as the message broker\n\nArchitecture\nThe app consists of 6 micro-services:\n\nGateway: The main entry point, responsible for routing requests to the respective services.\nAuth: Handles authentication and token validation using JWT.\nConverter: Transforms MP4 videos into MP3 audio files.\nNotify: Sends email notifications upon conversion completion.\nrabbitmq: Handles queue for converter and notify service.\n\nTechnologies\n\nDocker\nKubernetes\nMySQL\nMongoDB\nRabbitMQ\nFlask\n\nTODO\n\n Add Tests\n Implement the registration feature (planned for v0.2)\n Migrate the Gateway service to Django (planned for v0.3)\n"},"blog/Understanding-Networks:-A-Foundation":{"title":"Understanding Networks: A Foundation","links":[],"tags":[],"content":"Understanding Networks: A Foundation\nNetworks are an integral part of modern life. Whether you‚Äôre using your phone to control smart home devices or liking a friend‚Äôs post on Instagram, you‚Äôre interacting with networks. In these interactions, your device communicates with platforms like Instagram using a variety of network protocols and systems.\nNetwork Protocols\nThere are two primary types of network models:\n\nOSI Model\nTCP/IP Model\n\nLet‚Äôs explore these in detail, starting with the concept of layering.\n\nLayering in Networking\nLayering is a method used in computer science to break down complex systems into smaller, manageable components. This approach allows developers and engineers to focus on specific layers without worrying about the underlying details of others.\nExample:\nImagine you want to transfer a file from one city (City A) to another (City B). Whether you‚Äôre using a mobile network or fiber-optic cables, the system handles the physical transfer of data in its own layer. While this affects your download speed, you don‚Äôt need to know the intricate details of how it works‚Äîyou‚Äôre concerned only with the upper layers that handle your file transfer.\nAnother example of layering is video streaming. When you watch a movie on Netflix, the Application Layer ensures you see the video in your app, while lower layers manage the data transfer across the internet.\n\nThe TCP/IP Model\nThe TCP/IP Model (Transmission Control Protocol/Internet Protocol) is designed to ensure efficient and reliable data transmission. It consists of four layers:\n\nNetwork Access Layer: Handles the physical transmission of data.\nInternet Layer: Manages routing and addressing with protocols like IP.\nTransport Layer: Ensures end-to-end communication, reliability, and flow control using protocols such as TCP and UDP.\nApplication Layer: Interfaces with user applications, such as web browsers and email clients.\n\nHistory of TCP/IP\n\nDeveloped during the Cold War by the U.S. Department of Defense.\nFirst implemented as ARPANET in 1975, later becoming TCP/IP in 1983.\nIts primary goal was to enable seamless communication across different networks, leading to its adoption as the standard for global networking.\n\nExample:\nConsider an email service. When you send an email, the Transport Layer uses TCP to ensure reliable delivery, and the Application Layer uses SMTP (Simple Mail Transfer Protocol) to send the message to the recipient‚Äôs server.\n\nThe OSI Model\nThe OSI Model (Open Systems Interconnection) is a seven-layer framework that standardizes network communication. Each layer is responsible for a specific function in the communication process. The layers, from bottom to top, are:\n\nPhysical Layer: Transfers raw binary data (zeros and ones) through cables, wireless signals, etc.\nData Link Layer: Establishes reliable connections between devices on the same network.\nNetwork Layer: Handles routing and logical addressing (e.g., IP addresses).\nTransport Layer: Manages end-to-end communication, ports, and protocols.\nSession Layer: Establishes, maintains, and terminates communication sessions.\nPresentation Layer: Ensures data is in the correct format for the application layer.\nApplication Layer: Interfaces directly with user applications.\n\nComparison to TCP/IP\nWhile the OSI model is more theoretical, TCP/IP is a practical implementation widely used in real-world networking.\n\nLayer Details\nPhysical Layer\nThe Physical Layer is the foundation of the network, responsible for transmitting raw data via physical media like cables or wireless signals. Common media include:\n\nFiber-optic cables\nEthernet (RJ-45) cables\n\nExample:\nWhen you connect your laptop to a router using an Ethernet cable, the Physical Layer is responsible for sending and receiving raw electrical signals through the cable.\nData Link Layer\nBuilding on the Physical Layer, the Data Link Layer ensures reliable communication between devices. This layer handles issues like:\n\nCollisions: Prevents data conflicts using methods such as CSMA/CD or token passing.\nMAC Addresses: Unique identifiers assigned to network cards, used to route data locally.\nSwitches: Devices that manage data transmission within a network by mapping MAC addresses to ports.\n\nExample:\nIn a corporate office, if five computers are connected to a switch, the Data Link Layer ensures that when Computer A sends data to Computer B, only those two devices are involved in the communication, while the others remain unaffected.\nNetwork Layer\nThe Network Layer focuses on routing data between different networks. Key features include:\n\nLogical Addressing: Uses IP addresses (IPv4 or IPv6) to identify devices.\nRouting: Determines the best path for data to travel across networks using routers.\n\nExample:\nWhen accessing a website, your device sends a request to the server‚Äôs IP address. If the server is on a different network, routers at the Network Layer forward the request across multiple networks until it reaches the correct server.\nTransport Layer\nThe Transport Layer bridges the gap between network concepts and application needs. It handles:\n\nPorts: Allows multiple services to run on a single IP. For example:\n\nHTTP: Port 80\nHTTPS: Port 443\nFTP: Port 21\n\n\nProtocols:\n\nTCP (Transmission Control Protocol): Connection-oriented and reliable.\nUDP (User Datagram Protocol): Connectionless and faster, but less reliable.\n\n\n\nExample:\nIf you‚Äôre gaming online, UDP might be used because it prioritizes speed over reliability, ensuring minimal latency. However, when you‚Äôre downloading a file, TCP is used to ensure all parts of the file are received accurately.\n\nConclusion\nThis was a brief introduction to networks and how they function. We covered the basics of layering, the TCP/IP model, and the OSI model. For further reading, explore resources like the Cloudflare Learning Center or Wikipedia. In future articles, we‚Äôll delve deeper into topics like DNS and dynamic routing.\nThank you for reading!"},"index":{"title":"Welcome to Layer 0","links":["cv_embeded","cv.pdf","Projects/Api-Gateway","Projects/msd","Projects/SNA","blog/Understanding-Networks:-A-Foundation"],"tags":[],"content":"Hi, I‚Äôm Amin ‚Äî a backend developer and computer science student who enjoys building clean systems, solving complex problems, and working close to the metal.\nWhen I‚Äôm not coding, I‚Äôm probably halfway up a rock wall. Whether in code or climbing, I care about structure, stability, and the satisfaction of solving challenges from the ground up.\n\nüìÑ Resume\nYou can view my resume here or download it directly  here.\n\nüõ†Ô∏è Code &amp; Systems(Projects)\n\n\nAPI Gateway\nA lightweight API gateway built with Starlette and HTTPX, designed to handle routing and request management for microservices.\n\n\nMP4 to MP3 Converter\nA sample project demonstrating microservices architecture and asynchronous job handling, ideal for showcasing system design fundamentals.\n\n\nSocial Network Analysis Tool\nGraph-Based Social Network Analysis Tool + Visualization with d3.js\n\n\n\nThoughts &amp; Threads\n\nUnderstanding Networks: A Foundation\n\n\nü§ù Get in Touch\nI‚Äôm always open to new opportunities, collaborations, or just a good conversation. Feel free to reach out:\n\n\nüìß Email: aminmasoudi2003@gmail.com\n\n\nüí¨ Telegram\n\n\nüîó LinkedIn\n\n\nüêô GitHub\n\n\nThanks for stopping by. This site is a small reflection of what I‚Äôm building, learning, and exploring ‚Äî beneath the abstraction.\n‚Äî Amin"}}